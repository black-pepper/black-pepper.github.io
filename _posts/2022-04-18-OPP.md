---
layout: single
title: "객체 지향 프로그래밍 정리"
categories: Computer_Science
tag: [객체지향프로그래밍]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

** 객체지향 프로그래밍 수업 내용 정리입니다.  
** C# 기준으로 작성되었습니다.

---

## 데이터 타입(Data Type)

- 변수(Variable): 데이터를 담는 일정 크기의 공간
- 값 형식: 변수가 값을 담는 데이터 형식
- 참조 형식: 변수가 값 대신 값이 있는 곳의 위치(참조)를 담는 데이터 형식
- 기본 데이터 형식
  - 정수 계열 형식(Integral Types): byte, sbyte, short, ushort, int, uint, long, ulong, char
  - 부동 소수점 형식(Floating Point Types): float, double, decimal
  - 문자 형식: char / 문자열 형식: string
  - 논리 형식: bool
  - object 형식(참조 형식, 상속을 이용한 데이터 형식)
- 상수(Constant): 그 안에 담긴 데이터를 바꿀 수 없는 메모리 공간
- 열거형(Enumeration): 열거된 형태의 상수, enum 키워드를 이용하여 선언
- Nullable 형식: null한 변수가 필요할 때 사용. 데이터 형식 뒤에 '?'를 붙여서 사용. 예)int? a = null;
- var: 자동 형식 지정. 반드시 지역변수로 사용하고 초기값 필요.




## 연산자

- 산술 연산자
  - 수치 형식의 데이터를 다루는 연산자.
  - \+ - * / %
- 증가 연산자와 감소 연산자
  - 증가 연산자: 값을 1 증가, ++
  - 감소 연산자: 값을 1 감소, --
- 문자열 결합 연산자
  - String 형식에서 문자열을 결합, +
- 관계 연산자
  - 두 연산자 사이의 관계를 확인
  - < > <= >= == != 
- 논리 연산자
  - 참과 거짓으로 이루어지는 진리값이 피연산자인 연산
  - && \|\| !
- 조건 연산자
  - 조건에 따라 두 값 중 하나의 값을 반환
  - 조건식 ? 참일때의 값 : 거짓일때의 값
- 비트 연산자
  - 비트 수준에서 데이터를 가공하는 연산자
  - << >> & \| ^ ~ & \| ^ ~
- 할당 연산자
  - 변수 또는 상수에 피연산자를 할당
  - = += -= *= /= %= &= \|= ^= <<= >>=
<details>
<summary>연산자 우선순위</summary>
<div markdown="1">
- 후위 ++/-- 연산자
- 전위 ++/-- 연산자
- \* / %
- \+ -
-  << >>
- < > <= >= is as
- == !=
- &
- \^
- \|
- &&
- \|\|
- ?:
- \= *= /= %= += -= <<= >>= &= \|=
</div></details>



## 코드의 흐름 제어

- 분기문
  - 프로그램의 흐름을 조건에 따라 여러 갈래로 나누는 흐름 제어 구문
  - if, switch
- 반복문
  - 특정 조건을 만족하는 동안 코드 또는 코드 블록을 계속 반복해서 실행하도록하는 문장
  - while, do while, for, foreach
- 점프문
  - break, continue
  - goto



## 메소드(Method)

- 메소드
  - 일련의 코드를 하나의 이름 아래 묶은 것
  - OPP적인 의미에서는 객체의 데이터를 처리하는 방법을 추상화한 것
- return문
  - 메소드를 종결시키고 프로그램의 흐름을 호출자에게 돌려줌
  - 반환 형식이 void인 경우에도 return문 사용 가능
- 매개 변수
  - 메소드 외부에서 메소드 내부로 데이터를 전달
  - 변수가 담고있는 데이터가 복사되어 메소드 내부로 전달
- 참조에 의한 매개 변수 전달
  - 매개 변수가 메소드에 넘겨진 원본 변수를 직접 참조하게 하는 방법
  - 메소드 선언과 호출 시 ref 키워드 사용
- 출력 전용 매개 변수: out
- 메소드 오버로딩
  - 하나의 메소드 이름에 여러 개의 구현을 올리는 것
- 가변길이 매개 변수
  - 개수가 유연하게 변할 수 있는 매개 변수
  - params 키워드와 배열을 이용하여 선언
- 명명된 매개 변수
  - 메소드를 호출할 때 매개 변수의 이름을 명시하여 순서에 관계없이 매개변수에 할당할 데이터를 바인딩 가능
- 선택적 매개 변수
  - 메소드 선언 시 매개 변수에 기본값을 할당



## 클래스(Class)

- 클래스: 객체를 만들기 위한 청사진
- 생성자
  - 선언하지 않아도 컴파일러가 암시적으로 기본생성자 제공
  - 객체의 초기화에 필요한 파라미터를 입력받을 수 있음
- 복사
  - 얕은 복사: 객체에서 힙의 주소만 복사
  - 깊은 복사: 원본 객체와 별도의 객체를 할당하여 각 필드의 값을 복사
- this 키워드
  - 객체의 스스로를 가리키는 키워드
  - 객체 내부에서 자신의 필드나 메소드에 접근할 때 사용
- 접근 한정자
  - public: 클래스의 내부/외부 모든 곳에 접근 가능
  - protected: 클래스의 외부에서는 접근 불가, 파생 클래스에서는 접근 가능
  - private: 클래스의 내부에서만 접근 가능
  - internal: 같은 어셈블리에 있는 코드에 대해서만 public으로 접근 가능, 외부는 private
  - protected internal: 같은 어셈블리에 있는 코드에 대해서만 protected로 접근 가능. 외부는 private
- 상속
  - 한 클래스가 다른 클래스로부터 필드, 메소드, 프로퍼티 등을 물려 받는 것
  - 자식 클래스는 파생 클래스, 부모 클래스는 기반 클래스라고도 불림
  - 부모 클래스를 가리키는 키워드는 base
- 기반 클래스와 파상 클래스 사이의 형식 변환
  - 파생 클래스의 인스턴스는 기반 클래스의 인스턴스로써 사용 가능
- 다형성(Polymorphism)
  - 객체가 여러 형태를 가질 수 있음
  - 자신으로부터 상속받아 만들어진 파생 클래스를 통해 다형성을 실현
- 오버라이딩(Overriding)
  - 부모 클래스에서 선언된 메소드를 자식 클래스에서 재정의 하는 것
  - 부모 클래스에서 미리 virtual 한정자로 선언 필요
- 메소드 숨기기: 부모 클래스에서 virtual로 선언하지 않고, 자식 클래스에서 new 한정자를 이용하여 재선언하여 부모 클래스 버전의 메소드를 숨김
- 오버라이딩 봉인: sealed 한정자를 이용하여 메소드를 선언하면 파생클래스에서는 해당 메소드를 오버라이딩 할 수 없음
- 중첩 클래스: 클래스 안에 선언된 클래스
- 분할 클래스: 여러 번에 나눠서 구현하는 클래스
- 확장 메소드: 기존 클래스의 기능을 확장
- 구조체(struct)
  - 클래스처럼 필드와 메소드를 가질 수 있음
  - 첨조 형식은 값 형식, 복사는 깊은 복사, 인스턴스는 선언만으로도 생성이 가능



## 인터페이스(interface)와 추상클래스(abstract class)

- 인터페이스
  - 선언되어 있는 메소드를 구현하기만 한다면 해당 인터페이스를 지원하는 코드에는 그 인터페이스의 모든 파생클래스를 사용할 수 있음
  - 인터페이스를 인터페이스로 상속 가능
  - 다중 상속 가능 (여러개의 인터페이스를 한꺼번에 상속 가능)
- 추상 클래스
  - 인터페이스와 달리 구현을 가질 수 있음
  - 인스턴스를 가질 수 없음



## 프로퍼티(property)

- 자동 구현 프로퍼티: get, set 자동 구현

  - ```c#
    public class NameCard{
        public string Name{
            get; set;
        }
        public string PhoneNumber {
            get; set;
        }
    }
    ```

- 프로퍼티를 이용한 초기화

  - ```c#
    NameCard card = new NameCard(){
        Name = "홍길동",
        PhoneNumber = "010-1234-5678"
    }
    ```

- 무명 형식

  - 선언과 동시에 인스턴스를 할당하는 형식

  - 1회용 데이터 형식으로 사용

  - ```c#
    var card = new {Name="홍길동", PhoneNumber="010-1234-5678"}
    ```

- 추상 프로퍼티: 인터페이스처럼 구현되지 않은 프로퍼티



## 배열(Array), 컬렉션(Collection), 인덱서(Indexcer)

- 배열(Array)
  - 다수의 데이터를 한번에 다루기 위해 사용
  - 다차원 배열: 차원이 둘 이상인 배열
  - 가변 배열: 배열을 요소로 갖는 배열. 차원 단위에서 배열 크기 변경 가능
- 컬렉션(Collection)
  - 같은 성격을 띄는 데이터의 모음을 담는 구조
  - ArrayList, Queue, Stack, Hashtable
- 인덱서(Indexer)
  - 인덱스를 이용하여 객체 내의 데이터에 접근하게 해주는 프로퍼티



## 일반화 프로그래밍(Generalization)

- 일반화 프로그래밍: 데이터 형식 일반화를 이용하는 프로그래밍
- 일반화 메소드: 데이터 형식을 일반화한 메소드. void MyMethod\<T> ( T[] value)
- 일반화 클래스: 데이터 형식을 일반화한 클래스. class MyClass\<T>
- 일반화 컬렉션: 데이터 형식을 일반화한 컬렉션. List\<T>, Queue\<T>, Stack\<T>, Dictionary\<TKey, TValue>



## 델리게이트(Delegate)와 이벤트(Event)

- 콜백(Callback): 어떤 일을 대신 해 주는 코드

- 델리게이트(Delegate)

  - 메소드에 대한 참조.
  - 델리게이트에 메소드 주소를 할당한 후 델리게이트를 호출하면 할당된 메소드가 호출됨
  - 코드의 일부를 직접 정의해서 사용하고 싶을 때 사용

- 일반화 델리게이트:  일반화 메소드 참조 가능

- 델리게이트 체인: 델리게이트가 여러개의 메소드를 동시에 참조하여 델리게이트 호출 시 참조된 메소드를 하나씩 호출

- 익명 메소드: 이름이 없는 1회용 메소드

  - ```c#
    Calculate Calc = delegate(int a, int b) { return a+b; }
    ```

- 이벤트(Event)

  - 사건을 나타내는 객체
  - 델리게이트를 event 한정자로 수식하여 선언
  - 델리게이트와 달리 임의로 일으킬 수 없음



## 람다식(Lambda Expression)

- 람다식: 1회용 메소드(=익명 메소드)

  - ```c#
    Calculate Calc = (int a, int b) => a+b;
    ```

- 형식 유추: 람다식의 매개 변수를 컴파일러가 유추. (매개변수에서 형식 지정x)
