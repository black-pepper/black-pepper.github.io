---
layout: single
title: "컴퓨터 네트워크 3장 전송 계층"
categories: Computer_Science
tag: [컴퓨터 네트워크]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

** 컴퓨터 네트워크 수업 내용 정리입니다.  
** 컴퓨터 네트워크 - A Top-Down Approach (Behrouz A. Forouzan) 교재 내용을 참고하였습니다.  

---

## 1. 개요

### 1) 전송 계층 서비스

- 프로세스-대-프로세스 통신

- 주소체계: 포트번호

- ICANN: 잘 알려진 포트(0~1023), 등록된 포트(1024~49151), 동적 포트(49152~65535)

- 캡슐화와 역캡슐화

- 다중화(개체가 여러 소스로부터 정보를 수신)와 역다중화(개체가 여러 소스로 정보를 전달)

- 흐름 제어
  - 밀기(push)와 끌기(pull)
  - 전송 계층에서의 흐름 제어
  - 버퍼: 버퍼가 가득차거나 공간이 생기면 응용 계층에게 알림
  
- 오류 제어
  - 순서 번호: 패킷 순서 확인, 중복 패킷 감지
  - 확인응답: 오류가 없다면 확인응답, 오류는 폐기, 순서가 어긋나면 폐기 or 버퍼에 임시 저장 
  
- 흐름과 오류 제어의 결합
  - [슬라이딩 윈도우](https://url.kr/5amf9x)
  - 혼잡 제어
  
- 비연결형과 연결 지향 서비스
  - 비연결형 서비스: 흐름 제어, 오류 제어, 혼잡 제어가 없음
  
  - 연결 지향 서비스: 클라이언트와 서버 간 논리적 연결 설정. 흐름 제어, 오류 제어, 혼잡 제어 있음
  
    

<br>

## 2. 전송 계층 프로토콜

### 1) 단순 프로토콜

- FSM: 송신기와 수신기의 FSM은 각각 메시지 전달 요청, 패킷이 들어기 전까지 ready상태를 가짐

### 2) Stop-and-Wait 프로토콜

- 순서번호 & 확인응답 번호
  - 패킷을 중복 수신하지 않기 위해 순서 번호와 확인응답 번호를 사용
  - 패킷이 오류없이 도착하면 수신측은 확인 응답 전송
  - 패킷이 수신측에 도착하지 않으면 송신측이 타임아웃후에 패킷 재전송

- FSM
  - 송신측
    - Ready 상태: 응용 계층으로부터 요청이 발생하기를 기다리는 상태
    - Blocking 상태: 오류 없는 ACK가 도착, 훼손된 ACK 또는 확인응답 번호가 틀린 경우(→ACK 폐기), 타임 아웃 발생(→패킷 재전송)

  - 수신측
    - 항상 Ready 상태
    - 오류 없는 패킷 도착(→응용계층으로 전달), 순서 번호가 틀린 경우(→패킷 폐기, ACK 전송), 훼손된 패킷 도착(→패킷 폐기)

- 효율

  - 대역폭-지연곱: 비트로 표현된 파이프 용량. 대역 폭 x 왕복 지연시간

### 3) Go-Back-N 프로토콜

- 순서번호 & 확인응답 번호: 순서 번호는 modulo 2m(:순서 번호 필드의 비트 수), 확인응답 번호는 누적값(n-1번까지 모두 도착)
- 송신 윈도우: 전송 중이거나 전송될 데이터의 패킷의 순서 번호를 포함하는 가상의 상자
- 수신 윈도우: 패킷을 수신하고 올바른 확인응답이 전송될 수 있게 함. 수신 윈도우의 크기는 항상 1.
- 패킷 재전송: 타이머가 만료되면 모든 미해결 패킷들을 재전송
- FSM
  - 송신측
    - Read 상태: 응용 계층으로부터 요청이 들어오면 패킷 생성 후 전송, 윈도우가 다 차면 Blocking 상태.  오류가 없는 ACK가 들어오면 윈도우를 이동. 순서번호가 틀릴 경우 ACK 폐기. 타임-아웃이 발생하면 미해결 패킷을 모두 전송하고 타이머를 다시 구동
    - Blocking 상태:오류 없는 ACK가 도착하면 윈도우 이동, 훼손된 ACK 또는 확인응답 번호가 틀린 경우(→ACK 폐기), 타임 아웃 발생(→패킷 재전송)

  - 수신측
    - 항상 Ready상태
    - 오류 없는 패킷이 들어오면 메시지를 응용계층으로 전달 후 윈도우 이동, ACK 전송. 윈도우를 벗어난 패킷이 들어오면 패킷은 폐기되지만 ACK는 전송. 훼손된 패킷이 들어오면 패킷은 폐기

- 송신 윈도우 크기: 2^m보다 작아야 함

### 4) Selective-Repeat 프로토콜

- 윈도우: 송신 윈도우와 수신 위도우 두개를 사용
- 타이머: 패킷마다 하나의 타이머를 사용. 타이머가 만료되면 패킷 재전송
- 확인응답: Go-Back-N과 달리 ackNo는 오류 없이 수신된 하나의 패킷 순서 번호를 나타냄.
- FSM
  - 송신측
    - Ready 상태: 응용 계층으로부터 요청이 들어오면 패킷 생성 후 전송, 윈도우가 다 차면 Blocking 상태 . 오류가 없는 ACK가 들어오면 윈도우를 이동. 처리되지 않은 패킷과 관련된 ackNo를 갖지 않는 경우 ACK 폐기. 타임-아웃이 발생하면 미확인 응답된 패킷을 모두 전송하고 타이머를 다시 구동
    - Blocking 상태: 오류 없는 ACK가 도착하면 응답으로 표시하고  순서를 확인하여 같으면 윈도우 이동. 훼손된 ACK 또는 확인응답 번호가 틀린 경우(→ACK 폐기). 타임 아웃 발생(→패킷 재전송).
  - 수신측
    - 항상 Ready 상태
    - 오류 없는 패킷이 들어오면 메시지를 응용계층으로 전달 후 윈도우 이동, ACK 전송. 윈도우를 벗어난 패킷이 들어오면 패킷은 폐기되지만 ACK는 전송. 훼손된 패킷이 들어오면 패킷은 폐기
- 윈도우 크기: 송신윈도우와 수신 윈도우의 크기 모두 2^m의 반



### 5) 양방향 프로토콜: 피기배킹

- 피기배킹(piggybacking): 양방향 통신의 효율을 향상시키기 위해 사용



<br>

## 3. UDP (User Datagram protocol)

### 1) 사용자 데이터그램(user datagram)

- 2바이트 크기를 갖는 4개의 필드로 만들어진 8바이트의 고정된 헤더
- 처음 두 필드는 발신지와 목적지의 포트번호, 세번째 필드는 사용자 데이터그램의 총 필드 길이

### 2) UDP 서비스

- 프로세스-대-프로세스 통신
- 비연결형 서비스
- 흐름 제어: 없음
- 오류 제어: 검사합으로 오류를 감지하면 사용자 데이터그램 폐기.
- 혼잡 제어: 없음
- 캡슐화와 역캡슐화
- 큐잉
- 다중화와 역다중화
- UDP와 일반 단순 프로토콜과의 비교: UDP는 검사합을 사용하여 훼손된 패킷 감지



<br>

## 4. TCP (Transmission Control Protocol)

### 1) TCP 서비스

- 프로세스-대-프로세스 통신
- 스트림 배달 서비스: 바이트 스트림의 형태로 데이터 전송
  - 송신 버퍼와 수신 버퍼: 송신 및 수신 프로세스가 동일한 속도로 데이터를 생성하거나 소비하지 않을 수 있기 때문에 버퍼  사용
  - 세그먼트: TCP는 일련의 바이트를 세그먼트라고 하는 패킷으로 그룹화
- 전이중 통신: 양방향 데이터 전송 가능
- 다중화와 역다중화
- 연결 지향 서비스: 두 TCP간 가상 연결이 설정되고 데이터 교환 후 연결 종료
- 신뢰성 있는 서비스



### 2) TCP의 특징

- 번호화 시스템
  - 바이트 번호: 한 연결에서 전송되는 모든 데이터 바이트에 번호를 매김
  - 순서 번호: 바이트 번호가 매겨지면 TCP는 전송하고자 하는 세그먼트에 하나의 순서 번호를 할당
  - 확인응답 번호: 각각의 TCP는 서로 다른 시작 번호를 이용하여 바이트에 순서를 매김. 세그먼트 내의 확인응답 번호의 값은 수신하기를 기대하는 다음 바이트의 번호를 나타내고, 확인응답 번호는 누적.



### 3) 세그먼트(segment)

- 형식
  - 발신지 포트 주소: 전송 호스트에 있는 포트번호를 정의하는 16비트 필드
  - 목적지 포트 주소: 수신 호스트에 있는 포트번호를 정의하는 16비트 필드
  - 순서 번호: 32비트 필드
  - 확인응답 번호: 32비트 필트
  - 헤더 길이: 4비트 필드
  - 제어: 6개의 서로 다른 제어 비트 또는 플래그
  - 윈도우 크기: 16비트 필드. 따라서 윈도우의 최대 크기는 65,535바이트
  - 검사합: 16비트 필드
  - 긴급 포인터
  - 옵션
- 캡슐화: 응용 계층으로부터 들어온 데이터를 캡슐화



### 4) TCP 연결

- 연결 설정
  - [3단계 핸드쉐이킹](https://hyemsinabro.tistory.com/157)
  - 데이터 전송
    - 푸싱 데이터
    - 긴급 데이터
- 연결 종료
  - 3단계 핸드쉐이킹
  - Half-colose: 한쪽에서 데이터를 수신하면서 데이터 전송을 종료하는 것
- 연결 리셋



### 5) 상태 천이 다이어그램

- https://sostarzia.tistory.com/133

### 6) TCP 윈도우

- 송신 윈도우
  - TCP의 윈도우는 바이트의 번호

- 수신 윈도우
  - 확인응답 방법은 다음 바이트를 알려주는 누적 확인응답 방법




### 7) 흐름 제어

- 윈도우 열기와 닫기: 연결이 설정될 때 버퍼의 크기는 고정되지만 흐름 제어를 수행하기 위해 윈도우 크기 조정. 송신측에서 바이트가 들어오면 윈도우가 닫히고, 바이트가 수신되면 윈도우가 열림
- 어리석은 윈도우 신드롬
  - 전송 응용프로그램이 데이터를 천천히 발생하거나, 수신 응용프로그램이 데이터를 천천히 소비하는 경우, 아주 적은 수의 데이터를 포함하는 세그먼트의 전송으로 인해 동작 효율 감소
  - 송신측에 의한 신드롬 해결방안: [Nagle 알고리즘](https://ozt88.tistory.com/18)
  - 수신측에 의한 신드롬 해결방안: 데이터가 도착할 때 충분한 공간이 없다면 윈도우 크기를 0으로 통보하거나 확인응답의 전송을 지연




### 8) 오류 제어

- 검사합
- 확인응답
  - 누적 확인응답(ACK): 수신측에서 세그먼트가 폐기, 손실, 중복되면 피드백을 제공하지 않음
  - 선택 확인응답(SACK): 순서에 맞지 않게 들어온 데이터 블록과 중복 세그먼트를 알림
- 재전송
  - RTO(Retransmission Time-Out) 이후의 재전송: 송신 TCP에서 타임아웃이 발생하면 버퍼 앞에있는 세그먼트를 전송하고 타이머를 재구동
  - 세 개의 중복 ACK 세그먼트 이후에 재전송: 하나의 세그먼트에 대한 세개의 확인응답이 수신되면 타임아웃을 기다리지 않고 재전송(빠른 재전송)

- 순서에 맞지 않는 세그먼트: 일시적으로 저장. 순서에 맞지 않는 세그먼트로 표시.
- [TCP에서 데이터 전송을 위한 FSM](https://sectionr0.tistory.com/42)
- 몇 가지 시나리오
  - 정상 동작
  - 손실 세그먼트: 네트워크 내의 어딘가에서 폐기, 훼손 세그먼트: 수신자에 의해 폐기
  - 빠른 재전송: 동일한 확인응답이 네번(3개의 중복응답) 수신되면 세그먼트 즉시 재전송
  - 지연 세그먼트: 타임아웃 후 재전송된 지연 세그먼트(중복 세그먼트)는 폐기
  - 중복 세그먼트: 폐기, ACK 전송
  - 자동으로 교정되는 ACK의 손실: 누적 확인응답으로 손실 교정
  - 세그먼트를 재전송함으로써 교정되는 확인응답의 손실: RTO 타이머에 의해 교정
  - 확인응답의 손실로 인해 발생하는 교착상태: 송신측이 윈도우를 일시적으로 폐쇄하였다가 다시 받기 위해 보낸 rwnd 확인응답이 손실되는 경우 교착상태 발생



### 9) TCP 혼잡 제어

- 혼잡 윈도우: 전송되는 세그먼트들의 개수를 제어하기위해 cwnd변수 사용
- 혼잡 감지: 타임-아웃, 세개의 중복 ACK 수신 시 혼잡이 발생했다고 가정
- 혼잡 정책
  - 느린 시작: 지수 증가 - 임계치에 도달하기 전까지 지수적으로 증가
  - 혼잡 회피: 가산 증가 - 임계치에 도달하기 전까지 가산적으로 증가
- 전송 정책 
  - [Taho TCP, Reno TCP](https://velog.io/@nsh7293/TCP-Taho-TCP-Reno-TCP) 
  - NewReno TCP: Reno TCP에 최적화를 추가한 것
- TCP 처리량: Throughput = 0.75 * 혼잡이 일어날때의 윈도우 평균 크기 / RTT(Round Trip Time)



### 10) TCP 타이머

- 재전송 타이머: 재전송 타임-아웃(RTO)값으로 설정되는 하나의 재전송 타이머
- [왕복 시간(RTT, Round Trip Time)](http://ktword.co.kr/test/view/view.php?m_temp1=1687)
  - Karn 알고리즘: 새로운 RTT의 계산에 재전송 세그먼트의 왕복시간을 고려하지 않는 것
  - 지수 백오프: 세그먼트가 재전송될 때마다 RTO의 값은 두배가 됨
- 영속 타이머: 교착상태를 해결하기 위해 사용하는 타이머
- 킵얼라이브 타이머(keepalive timer): 두 TCP 사이에 설정된 연결이 오랜 기간 동안 휴지 상태에 있는 것을 방지하기 위해 사용하는 타이머
- 시간 대기 타이머: 연결 종료 동안 사용되는 타이머